; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\timer.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\timer.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=536 --omf_browse=.\obj\timer.crf ..\..\..\Library\StdDriver\src\timer.c]
                          THUMB

                          AREA ||i.TIMER_CaptureSelect||, CODE, READONLY, ALIGN=1

                  TIMER_CaptureSelect PROC
;;;366      */
;;;367    void TIMER_CaptureSelect(TIMER_T *timer, uint32_t u32Src)
000000  2201              MOVS     r2,#1
;;;368    {
;;;369        if (u32Src == TIMER_CAPTURE_FROM_EXTERNAL)
;;;370        {
;;;371            timer->CTL = (timer->CTL & ~(TIMER_CTL_CAPSRC_Msk)) |
000002  0412              LSLS     r2,r2,#16
000004  29ff              CMP      r1,#0xff              ;369
000006  d009              BEQ      |L1.28|
;;;372                         (TIMER_CAPSRC_TX_EXT);
;;;373        }
;;;374        else
;;;375        {
;;;376            timer->CTL = (timer->CTL & ~(TIMER_CTL_CAPSRC_Msk)) |
000008  6803              LDR      r3,[r0,#0]
00000a  4313              ORRS     r3,r3,r2
00000c  6003              STR      r3,[r0,#0]
;;;377                         (TIMER_CAPSRC_INTERNAL);
;;;378            timer->EXTCTL = (timer->EXTCTL & ~(TIMER_EXTCTL_INTERCAPSEL_Msk)) |
00000e  6942              LDR      r2,[r0,#0x14]
000010  2307              MOVS     r3,#7
000012  021b              LSLS     r3,r3,#8
000014  439a              BICS     r2,r2,r3
000016  430a              ORRS     r2,r2,r1
000018  6142              STR      r2,[r0,#0x14]
;;;379                            (u32Src);
;;;380        }
;;;381    }
00001a  4770              BX       lr
                  |L1.28|
00001c  6801              LDR      r1,[r0,#0]            ;371
00001e  4391              BICS     r1,r1,r2              ;371
000020  6001              STR      r1,[r0,#0]            ;371
000022  4770              BX       lr
;;;382    
                          ENDP


                          AREA ||i.TIMER_Close||, CODE, READONLY, ALIGN=1

                  TIMER_Close PROC
;;;76       */
;;;77     void TIMER_Close(TIMER_T *timer)
000000  2100              MOVS     r1,#0
;;;78     {
;;;79         timer->CTL = 0;
000002  6001              STR      r1,[r0,#0]
;;;80         timer->EXTCTL = 0;
000004  6141              STR      r1,[r0,#0x14]
;;;81     }
000006  4770              BX       lr
;;;82     
                          ENDP


                          AREA ||i.TIMER_Delay||, CODE, READONLY, ALIGN=2

                  TIMER_Delay PROC
;;;96       */
;;;97     int32_t TIMER_Delay(TIMER_T *timer, uint32_t u32Usec)
000000  b5f8              PUSH     {r3-r7,lr}
;;;98     {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;99         uint32_t u32Clk = TIMER_GetModuleClock(timer);
000006  f7fffffe          BL       TIMER_GetModuleClock
;;;100        uint32_t u32Prescale = 0UL, u32Delay;
00000a  2600              MOVS     r6,#0
00000c  4607              MOV      r7,r0                 ;99
;;;101        uint32_t u32Cmpr, u32Cntr, u32NsecPerTick, i = 0UL;
;;;102    
;;;103        /* Clear current timer configuration */
;;;104        timer->CTL = 0;
00000e  6026              STR      r6,[r4,#0]
;;;105        timer->EXTCTL = 0;
000010  6166              STR      r6,[r4,#0x14]
;;;106    
;;;107        if(u32Clk <= 1000000)   /* min delay is 1000 us if timer clock source is <= 1 MHz */
000012  4929              LDR      r1,|L3.184|
000014  4288              CMP      r0,r1
000016  d805              BHI      |L3.36|
;;;108        {
;;;109            if(u32Usec < 1000)
000018  207d              MOVS     r0,#0x7d
00001a  00c0              LSLS     r0,r0,#3
00001c  4285              CMP      r5,r0
00001e  d205              BCS      |L3.44|
;;;110                u32Usec = 1000;
000020  4605              MOV      r5,r0
000022  e006              B        |L3.50|
                  |L3.36|
;;;111            if(u32Usec > 1000000)
;;;112                u32Usec = 1000000;
;;;113        }
;;;114        else
;;;115        {
;;;116            if(u32Usec < 100)
000024  2d64              CMP      r5,#0x64
000026  d201              BCS      |L3.44|
;;;117                u32Usec = 100;
000028  2564              MOVS     r5,#0x64
00002a  e002              B        |L3.50|
                  |L3.44|
;;;118            if(u32Usec > 1000000)
00002c  428d              CMP      r5,r1
00002e  d900              BLS      |L3.50|
;;;119                u32Usec = 1000000;
000030  460d              MOV      r5,r1
                  |L3.50|
;;;120        }
;;;121    
;;;122        if(u32Clk <= 1000000)
000032  428f              CMP      r7,r1
000034  d809              BHI      |L3.74|
;;;123        {
;;;124            u32Prescale = 0;
;;;125            u32NsecPerTick = 1000000000 / u32Clk;
000036  4639              MOV      r1,r7
000038  4820              LDR      r0,|L3.188|
00003a  f7fffffe          BL       __aeabi_uidivmod
00003e  4601              MOV      r1,r0
;;;126            u32Cmpr = (u32Usec * 1000) / u32NsecPerTick;
000040  227d              MOVS     r2,#0x7d
000042  4628              MOV      r0,r5
000044  00d2              LSLS     r2,r2,#3
000046  4350              MULS     r0,r2,r0
000048  e006              B        |L3.88|
                  |L3.74|
;;;127        }
;;;128        else
;;;129        {
;;;130            u32Cmpr = u32Usec * (u32Clk / 1000000);
00004a  4638              MOV      r0,r7
00004c  f7fffffe          BL       __aeabi_uidivmod
000050  4368              MULS     r0,r5,r0
;;;131            u32Prescale = (u32Cmpr >> 24);  /* for 24 bits CMPDAT */
000052  0e06              LSRS     r6,r0,#24
;;;132            if (u32Prescale > 0)
000054  d002              BEQ      |L3.92|
;;;133                u32Cmpr = u32Cmpr / (u32Prescale + 1);
000056  1c71              ADDS     r1,r6,#1
                  |L3.88|
000058  f7fffffe          BL       __aeabi_uidivmod
                  |L3.92|
;;;134        }
;;;135    
;;;136        timer->CMP = u32Cmpr;
00005c  6060              STR      r0,[r4,#4]
;;;137        timer->CTL = TIMER_CTL_CNTEN_Msk | TIMER_ONESHOT_MODE | u32Prescale;
00005e  2001              MOVS     r0,#1
000060  0780              LSLS     r0,r0,#30
000062  4330              ORRS     r0,r0,r6
000064  6020              STR      r0,[r4,#0]
;;;138    
;;;139        /* When system clock is faster than timer clock, it is possible timer active bit cannot set
;;;140           in time while we check it. And the while loop below return immediately, so put a tiny
;;;141           delay larger than 1 ECLK here allowing timer start counting and raise active flag. */
;;;142        for(u32Delay = (SystemCoreClock / u32Clk) + 1UL; u32Delay > 0UL; u32Delay--)
000066  4d16              LDR      r5,|L3.192|
000068  4639              MOV      r1,r7
00006a  6828              LDR      r0,[r5,#0]  ; SystemCoreClock
00006c  f7fffffe          BL       __aeabi_uidivmod
000070  1c40              ADDS     r0,r0,#1
000072  d002              BEQ      |L3.122|
                  |L3.116|
;;;143        {
;;;144            __NOP();
000074  bf00              NOP      
000076  1e40              SUBS     r0,r0,#1
000078  d1fc              BNE      |L3.116|
                  |L3.122|
;;;145        }
;;;146    
;;;147        /* Add a bail out counter here in case timer clock source is disabled accidentally.
;;;148           Prescale counter reset every ECLK * (prescale value + 1).
;;;149           The u32Delay here is to make sure timer counter value changed when prescale counter reset */
;;;150        u32Delay = (SystemCoreClock / TIMER_GetModuleClock(timer)) * (u32Prescale + 1);
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       TIMER_GetModuleClock
000080  4601              MOV      r1,r0
000082  6828              LDR      r0,[r5,#0]  ; SystemCoreClock
000084  f7fffffe          BL       __aeabi_uidivmod
000088  1c76              ADDS     r6,r6,#1
00008a  4370              MULS     r0,r6,r0
;;;151        u32Cntr = timer->CNT;
00008c  68e1              LDR      r1,[r4,#0xc]
00008e  4603              MOV      r3,r0                 ;150
;;;152        i = 0;
000090  2000              MOVS     r0,#0
;;;153        while(timer->CTL & TIMER_CTL_ACTSTS_Msk)
000092  e00b              B        |L3.172|
                  |L3.148|
;;;154        {
;;;155            /* Bailed out if timer stop counting e.g. Some interrupt handler close timer clock source. */
;;;156            if(u32Cntr == timer->CNT)
000094  68e2              LDR      r2,[r4,#0xc]
000096  428a              CMP      r2,r1
000098  d106              BNE      |L3.168|
;;;157            {
;;;158                if(i++ > u32Delay)
00009a  4602              MOV      r2,r0
00009c  1c40              ADDS     r0,r0,#1
00009e  429a              CMP      r2,r3
0000a0  d904              BLS      |L3.172|
;;;159                {
;;;160                    return TIMER_TIMEOUT_ERR;
0000a2  2000              MOVS     r0,#0
0000a4  43c0              MVNS     r0,r0
;;;161                }
;;;162            }
;;;163            else
;;;164            {
;;;165                i = 0;
;;;166                u32Cntr = timer->CNT;
;;;167            }
;;;168        }
;;;169        return 0;
;;;170    }
0000a6  bdf8              POP      {r3-r7,pc}
                  |L3.168|
0000a8  68e1              LDR      r1,[r4,#0xc]          ;166
0000aa  2000              MOVS     r0,#0                 ;165
                  |L3.172|
0000ac  6822              LDR      r2,[r4,#0]            ;153
0000ae  0192              LSLS     r2,r2,#6              ;153
0000b0  d4f0              BMI      |L3.148|
0000b2  2000              MOVS     r0,#0                 ;169
0000b4  bdf8              POP      {r3-r7,pc}
;;;171    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L3.184|
                          DCD      0x000f4240
                  |L3.188|
                          DCD      0x3b9aca00
                  |L3.192|
                          DCD      SystemCoreClock

                          AREA ||i.TIMER_DisableCapture||, CODE, READONLY, ALIGN=1

                  TIMER_DisableCapture PROC
;;;204      */
;;;205    void TIMER_DisableCapture(TIMER_T *timer)
000000  6941              LDR      r1,[r0,#0x14]
;;;206    {
;;;207        timer->EXTCTL &= ~TIMER_EXTCTL_CAPEN_Msk;
000002  2208              MOVS     r2,#8
000004  4391              BICS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;208    }
000008  4770              BX       lr
;;;209    
                          ENDP


                          AREA ||i.TIMER_DisableEventCounter||, CODE, READONLY, ALIGN=1

                  TIMER_DisableEventCounter PROC
;;;238      */
;;;239    void TIMER_DisableEventCounter(TIMER_T *timer)
000000  6801              LDR      r1,[r0,#0]
;;;240    {
;;;241        timer->CTL &= ~TIMER_CTL_EXTCNTEN_Msk;
000002  2201              MOVS     r2,#1
000004  0612              LSLS     r2,r2,#24
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;242    }
00000a  4770              BX       lr
;;;243    
                          ENDP


                          AREA ||i.TIMER_DisableFreqCounter||, CODE, READONLY, ALIGN=1

                  TIMER_DisableFreqCounter PROC
;;;314      */
;;;315    void TIMER_DisableFreqCounter(TIMER_T *timer)
000000  6801              LDR      r1,[r0,#0]
;;;316    {
;;;317        timer->CTL &= ~TIMER_CTL_INTRGEN_Msk;
000002  2201              MOVS     r2,#1
000004  0292              LSLS     r2,r2,#10
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;318    }
00000a  4770              BX       lr
;;;319    
                          ENDP


                          AREA ||i.TIMER_EnableCapture||, CODE, READONLY, ALIGN=1

                  TIMER_EnableCapture PROC
;;;189      */
;;;190    void TIMER_EnableCapture(TIMER_T *timer, uint32_t u32CapMode, uint32_t u32Edge)
000000  b510              PUSH     {r4,lr}
;;;191    {
;;;192        timer->EXTCTL = (timer->EXTCTL & ~(TIMER_EXTCTL_CAPFUNCS_Msk | TIMER_EXTCTL_CAPEDGE_Msk)) |
000002  6943              LDR      r3,[r0,#0x14]
000004  2416              MOVS     r4,#0x16
000006  43a3              BICS     r3,r3,r4
000008  430b              ORRS     r3,r3,r1
00000a  4313              ORRS     r3,r3,r2
00000c  2108              MOVS     r1,#8
00000e  430b              ORRS     r3,r3,r1
000010  6143              STR      r3,[r0,#0x14]
;;;193                        u32CapMode | u32Edge | TIMER_EXTCTL_CAPEN_Msk;
;;;194    }
000012  bd10              POP      {r4,pc}
;;;195    
                          ENDP


                          AREA ||i.TIMER_EnableEventCounter||, CODE, READONLY, ALIGN=1

                  TIMER_EnableEventCounter PROC
;;;223      */
;;;224    void TIMER_EnableEventCounter(TIMER_T *timer, uint32_t u32Edge)
000000  6942              LDR      r2,[r0,#0x14]
;;;225    {
;;;226        timer->EXTCTL = (timer->EXTCTL & ~TIMER_EXTCTL_CNTPHASE_Msk) | u32Edge;
000002  0852              LSRS     r2,r2,#1
000004  0052              LSLS     r2,r2,#1
000006  430a              ORRS     r2,r2,r1
000008  6142              STR      r2,[r0,#0x14]
;;;227        timer->CTL |= TIMER_CTL_EXTCNTEN_Msk;
00000a  6801              LDR      r1,[r0,#0]
00000c  2201              MOVS     r2,#1
00000e  0612              LSLS     r2,r2,#24
000010  4311              ORRS     r1,r1,r2
000012  6001              STR      r1,[r0,#0]
;;;228    }
000014  4770              BX       lr
;;;229    
                          ENDP


                          AREA ||i.TIMER_EnableFreqCounter||, CODE, READONLY, ALIGN=2

                  TIMER_EnableFreqCounter PROC
;;;294      */
;;;295    void TIMER_EnableFreqCounter(TIMER_T *timer, uint32_t u32DropCount, uint32_t u32Timeout, uint32_t u32EnableInt)
000000  4908              LDR      r1,|L9.36|
;;;296    {
;;;297        TIMER_T *t;    /* store the timer base to configure compare value */
;;;298    
;;;299        t = (timer == TIMER0) ? TIMER1 : TIMER3;
000002  4288              CMP      r0,r1
000004  d102              BNE      |L9.12|
000006  4907              LDR      r1,|L9.36|
000008  3120              ADDS     r1,r1,#0x20
00000a  e000              B        |L9.14|
                  |L9.12|
00000c  4906              LDR      r1,|L9.40|
                  |L9.14|
;;;300    
;;;301        t->CMP = 0xFFFFFF;
00000e  4a07              LDR      r2,|L9.44|
000010  604a              STR      r2,[r1,#4]
;;;302        t->EXTCTL = u32EnableInt ? TIMER_EXTCTL_CAPIEN_Msk : 0;
000012  2b00              CMP      r3,#0
000014  d001              BEQ      |L9.26|
000016  2220              MOVS     r2,#0x20
000018  e000              B        |L9.28|
                  |L9.26|
00001a  2200              MOVS     r2,#0
                  |L9.28|
00001c  614a              STR      r2,[r1,#0x14]
;;;303        timer->CTL = TIMER_CTL_INTRGEN_Msk | TIMER_CTL_CNTEN_Msk;
00001e  4904              LDR      r1,|L9.48|
000020  6001              STR      r1,[r0,#0]
;;;304    
;;;305        return;
;;;306    }
000022  4770              BX       lr
;;;307    
                          ENDP

                  |L9.36|
                          DCD      0x40050000
                  |L9.40|
                          DCD      0x40051020
                  |L9.44|
                          DCD      0x00ffffff
                  |L9.48|
                          DCD      0x40000400

                          AREA ||i.TIMER_GetModuleClock||, CODE, READONLY, ALIGN=2

                  TIMER_GetModuleClock PROC
;;;253      */
;;;254    uint32_t TIMER_GetModuleClock(TIMER_T *timer)
000000  b510              PUSH     {r4,lr}
;;;255    {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;256        uint32_t u32Src;
;;;257        const uint32_t au32Clk[] = {__HXT, __LXT, 0, 0, 0, __LIRC, 0, __HIRC};
000006  2220              MOVS     r2,#0x20
000008  4915              LDR      r1,|L10.96|
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       __aeabi_memcpy4
;;;258    
;;;259        if(timer == TIMER0)
;;;260            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR0SEL_Msk) >> CLK_CLKSEL1_TMR0SEL_Pos;
;;;261        else if(timer == TIMER1)
000010  4b14              LDR      r3,|L10.100|
000012  4a14              LDR      r2,|L10.100|
000014  4814              LDR      r0,|L10.104|
000016  3320              ADDS     r3,r3,#0x20
000018  4294              CMP      r4,r2                 ;259
00001a  d102              BNE      |L10.34|
00001c  6940              LDR      r0,[r0,#0x14]         ;260
;;;262            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR1SEL_Msk) >> CLK_CLKSEL1_TMR1SEL_Pos;
;;;263        else if(timer == TIMER2)
;;;264            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR2SEL_Msk) >> CLK_CLKSEL1_TMR2SEL_Pos;
;;;265        else  /* Timer 3 */
;;;266            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR3SEL_Msk) >> CLK_CLKSEL1_TMR3SEL_Pos;
;;;267    
;;;268        if(u32Src == 2)
;;;269        {
;;;270            if ((timer == TIMER0) || (timer == TIMER1))
;;;271                return CLK_GetPCLK0Freq();
;;;272            else
;;;273                return CLK_GetPCLK1Freq();
;;;274        }
;;;275    
;;;276        return (au32Clk[u32Src]);
;;;277    }
00001e  0a00              LSRS     r0,r0,#8
000020  e00b              B        |L10.58|
                  |L10.34|
000022  429c              CMP      r4,r3                 ;261
000024  d102              BNE      |L10.44|
000026  6940              LDR      r0,[r0,#0x14]         ;262
000028  0b00              LSRS     r0,r0,#12
00002a  e006              B        |L10.58|
                  |L10.44|
00002c  490f              LDR      r1,|L10.108|
00002e  6940              LDR      r0,[r0,#0x14]         ;266
000030  428c              CMP      r4,r1                 ;263
000032  d101              BNE      |L10.56|
000034  0c00              LSRS     r0,r0,#16
000036  e000              B        |L10.58|
                  |L10.56|
000038  0d00              LSRS     r0,r0,#20
                  |L10.58|
00003a  0741              LSLS     r1,r0,#29
00003c  0f49              LSRS     r1,r1,#29
00003e  2902              CMP      r1,#2                 ;268
000040  d004              BEQ      |L10.76|
000042  0088              LSLS     r0,r1,#2              ;276
000044  4669              MOV      r1,sp                 ;276
000046  5808              LDR      r0,[r1,r0]            ;276
                  |L10.72|
000048  b008              ADD      sp,sp,#0x20
00004a  bd10              POP      {r4,pc}
                  |L10.76|
00004c  4294              CMP      r4,r2                 ;270
00004e  d001              BEQ      |L10.84|
000050  429c              CMP      r4,r3                 ;270
000052  d102              BNE      |L10.90|
                  |L10.84|
000054  f7fffffe          BL       CLK_GetPCLK0Freq
000058  e7f6              B        |L10.72|
                  |L10.90|
00005a  f7fffffe          BL       CLK_GetPCLK1Freq
00005e  e7f3              B        |L10.72|
;;;278    
                          ENDP

                  |L10.96|
                          DCD      ||.constdata||
                  |L10.100|
                          DCD      0x40050000
                  |L10.104|
                          DCD      0x40000200
                  |L10.108|
                          DCD      0x40051000

                          AREA ||i.TIMER_Open||, CODE, READONLY, ALIGN=1

                  TIMER_Open PROC
;;;43       */
;;;44     uint32_t TIMER_Open(TIMER_T *timer, uint32_t u32Mode, uint32_t u32Freq)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;45     {
000002  4617              MOV      r7,r2
000004  4606              MOV      r6,r0
;;;46         uint32_t u32Clk = TIMER_GetModuleClock(timer);
000006  f7fffffe          BL       TIMER_GetModuleClock
00000a  4605              MOV      r5,r0
;;;47         uint32_t u32Cmpr = 0, u32Prescale = 0;
00000c  2400              MOVS     r4,#0
;;;48     
;;;49         /* Fastest possible timer working freq is (u32Clk / 2). While cmpr = 2, pre-scale = 0. */
;;;50         if(u32Freq >= (u32Clk >> 1))
00000e  0840              LSRS     r0,r0,#1
000010  42b8              CMP      r0,r7
000012  d801              BHI      |L11.24|
;;;51         {
;;;52             u32Cmpr = 2;
000014  2002              MOVS     r0,#2
000016  e008              B        |L11.42|
                  |L11.24|
;;;53         }
;;;54         else
;;;55         {
;;;56             u32Cmpr = u32Clk / u32Freq;
000018  4639              MOV      r1,r7
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       __aeabi_uidivmod
;;;57             u32Prescale = (u32Cmpr >> 24);  /* for 24 bits CMPDAT */
000020  0e04              LSRS     r4,r0,#24
;;;58             if (u32Prescale > 0)
000022  d002              BEQ      |L11.42|
;;;59                 u32Cmpr = u32Cmpr / (u32Prescale + 1);
000024  1c61              ADDS     r1,r4,#1
000026  f7fffffe          BL       __aeabi_uidivmod
                  |L11.42|
;;;60         }
;;;61     
;;;62         timer->CTL = u32Mode | u32Prescale;
00002a  9901              LDR      r1,[sp,#4]
00002c  4321              ORRS     r1,r1,r4
00002e  6031              STR      r1,[r6,#0]
;;;63         timer->CMP = u32Cmpr;
000030  6070              STR      r0,[r6,#4]
000032  1c64              ADDS     r4,r4,#1
;;;64     
;;;65         return(u32Clk / (u32Cmpr * (u32Prescale + 1)));
000034  4360              MULS     r0,r4,r0
000036  4601              MOV      r1,r0
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       __aeabi_uidivmod
;;;66     }
00003e  bdfe              POP      {r1-r7,pc}
;;;67     
                          ENDP


                          AREA ||i.TIMER_ResetCounter||, CODE, READONLY, ALIGN=2

                  TIMER_ResetCounter PROC
;;;393      */
;;;394    int32_t TIMER_ResetCounter(TIMER_T *timer)
000000  b510              PUSH     {r4,lr}
;;;395    {
000002  4604              MOV      r4,r0
;;;396        uint32_t u32Delay;
;;;397    
;;;398        timer->CTL |= TIMER_CTL_RSTCNT_Msk;
000004  6800              LDR      r0,[r0,#0]
000006  2101              MOVS     r1,#1
000008  0689              LSLS     r1,r1,#26
00000a  4308              ORRS     r0,r0,r1
00000c  6020              STR      r0,[r4,#0]
;;;399        /* Takes 2~3 ECLKs to reset timer counter */
;;;400        u32Delay = (SystemCoreClock / TIMER_GetModuleClock(timer)) * 3;
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       TIMER_GetModuleClock
000014  4601              MOV      r1,r0
000016  480a              LDR      r0,|L12.64|
000018  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00001a  f7fffffe          BL       __aeabi_uidivmod
00001e  0041              LSLS     r1,r0,#1
000020  1840              ADDS     r0,r0,r1
;;;401        while(((timer->CTL & TIMER_CTL_RSTCNT_Msk) == TIMER_CTL_RSTCNT_Msk) && (--u32Delay))
000022  e000              B        |L12.38|
                  |L12.36|
;;;402        {
;;;403            __NOP();
000024  bf00              NOP      
                  |L12.38|
000026  6821              LDR      r1,[r4,#0]            ;401
000028  0149              LSLS     r1,r1,#5              ;401
00002a  d502              BPL      |L12.50|
00002c  1e40              SUBS     r0,r0,#1              ;401
00002e  d1f9              BNE      |L12.36|
000030  e003              B        |L12.58|
                  |L12.50|
;;;404        }
;;;405        return u32Delay > 0 ? 0 : TIMER_TIMEOUT_ERR;
000032  2800              CMP      r0,#0
000034  d001              BEQ      |L12.58|
000036  2000              MOVS     r0,#0
;;;406    }
000038  bd10              POP      {r4,pc}
                  |L12.58|
00003a  2000              MOVS     r0,#0                 ;405
00003c  43c0              MVNS     r0,r0                 ;405
00003e  bd10              POP      {r4,pc}
;;;407    
                          ENDP

                  |L12.64|
                          DCD      SystemCoreClock

                          AREA ||i.TIMER_SetTriggerSource||, CODE, READONLY, ALIGN=1

                  TIMER_SetTriggerSource PROC
;;;329      */
;;;330    void TIMER_SetTriggerSource(TIMER_T *timer, uint32_t u32Src)
000000  6802              LDR      r2,[r0,#0]
;;;331    {
;;;332        timer->CTL = (timer->CTL & ~TIMER_CTL_TRGSSEL_Msk) | u32Src;
000002  2301              MOVS     r3,#1
000004  049b              LSLS     r3,r3,#18
000006  439a              BICS     r2,r2,r3
000008  430a              ORRS     r2,r2,r1
00000a  6002              STR      r2,[r0,#0]
;;;333    }
00000c  4770              BX       lr
;;;334    
                          ENDP


                          AREA ||i.TIMER_SetTriggerTarget||, CODE, READONLY, ALIGN=2

                  TIMER_SetTriggerTarget PROC
;;;346      */
;;;347    void TIMER_SetTriggerTarget(TIMER_T *timer, uint32_t u32Mask)
000000  6802              LDR      r2,[r0,#0]
;;;348    {
;;;349        timer->CTL = (timer->CTL & ~(TIMER_CTL_TRGPWM_Msk | TIMER_CTL_TRGADC_Msk | TIMER_CTL_TRGPDMA_Msk | TIMER_CTL_TRGBPWM_Msk)) | (u32Mask);
000002  4b02              LDR      r3,|L14.12|
000004  401a              ANDS     r2,r2,r3
000006  430a              ORRS     r2,r2,r1
000008  6002              STR      r2,[r0,#0]
;;;350    }
00000a  4770              BX       lr
;;;351    
                          ENDP

                  |L14.12|
                          DCD      0xffd7fcff

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x01e84800
                          DCD      0x00008000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00009600
                          DCD      0x00000000
                          DCD      0x02dc6c00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\timer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_5bec749a____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_timer_c_5bec749a____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_5bec749a____REVSH|
#line 402
|__asm___7_timer_c_5bec749a____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
